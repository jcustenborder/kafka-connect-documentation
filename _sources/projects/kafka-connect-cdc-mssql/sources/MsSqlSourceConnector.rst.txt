====================
Microsoft SQL Server
====================

The Microsoft SQL Server connector utilizes `Change Tracking <https://msdn.microsoft.com/en-us/library/bb933875.aspx>`_ to identify changes. There are two ways to read the changes from the source system as they are generated. `Change Data Capture <https://msdn.microsoft.com/en-us/library/cc645937.aspx>`_ is a feature that is only available on SQL Server Enterprise and Developer editions. `Change Tracking <https://msdn.microsoft.com/en-us/library/bb933875.aspx>`_ is a lightweight solution that will efficiently find rows that have changed. If the rows are modified in quick succession all of the changes might not be found. The latest version of the change will be returned.


.. WARNING::
    :ref:`Tasks <connect_tasks>` are used to spread the work across the Connect cluster. The connector will partition all of the tables with Change Tracking enabled across the number of tasks allocated to the connector. Each task will have at least one connection to the source database server.


.. IMPORTANT::
    This connector utilizes the `Change Tracking <https://msdn.microsoft.com/en-us/library/bb933875.aspx>`_ featureavailable in most versions of SQL Server. For this connector to detect changes you must `enable Change Tracking <https://docs.microsoft.com/en-us/sql/relational-databases/track-changes/enable-and-disable-change-tracking-sql-server>`_ on the source database server.



-------------
Configuration
-------------

-------------------
Database Connection
-------------------


^^^^^^^^^^^^^^^^
initial.database
^^^^^^^^^^^^^^^^

The initial database to connect to.

**Importance:** High

**Type:** String



^^^^^^^^
password
^^^^^^^^

JDBC Password to connect to the database with.

**Importance:** High

**Type:** Password



^^^^^^^^^^^
server.name
^^^^^^^^^^^

The database server to connect to.

**Importance:** High

**Type:** String



^^^^^^^^^^^
server.port
^^^^^^^^^^^

The port on the database server to connect to.

**Importance:** High

**Type:** Int



^^^^^^^^
username
^^^^^^^^

JDBC Username to connect to the database with.

**Importance:** High

**Type:** String



^^^^^^^^^^^^^^^^^^^^^^
change.tracking.tables
^^^^^^^^^^^^^^^^^^^^^^

The tables in the source database to monitor for changes. If no tables are specified the `[sys].[change_tracking_tables]` view is queried for all of the available tables with change tracking enabled.

**Importance:** Medium

**Type:** List

**Default Value:** []



^^^^^^^^^^^^^^^^^^
jdbc.pool.max.idle
^^^^^^^^^^^^^^^^^^

The maximum number of idle CONNECTIONS in the connection pool.

**Importance:** Medium

**Type:** Int

**Default Value:** 10



^^^^^^^^^^^^^^^^^^^
jdbc.pool.max.total
^^^^^^^^^^^^^^^^^^^

The maximum number of CONNECTIONS for the connection pool to open. If a number greater than this value is requested, the caller will block waiting for a connection to be returned. This setting is shared across all of the tasks for a given database.

**Importance:** Medium

**Type:** Int

**Default Value:** 30



^^^^^^^^^^^^^^^^^^
jdbc.pool.min.idle
^^^^^^^^^^^^^^^^^^

The minimum number of idle CONNECTIONS in the connection pool.

**Importance:** Medium

**Type:** Int

**Default Value:** 3



^^^^^^^^^^^^^
instance.name
^^^^^^^^^^^^^

The instance name for the SQL Server we are connecting to.

**Importance:** Low

**Type:** String



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
multi.subnet.failover.enabled
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Flag to enable the multisubnet failover option.

**Importance:** Low

**Type:** Boolean

**Default Value:** false



------
Schema
------


^^^^^^^^^^^^^^^^^^^^^^
schema.key.name.format
^^^^^^^^^^^^^^^^^^^^^^

Format used to generate the name for the key schema. The following template variables are available for string replacement. `${databaseName}`, `${schemaName}`, `${tableName}`, `${namespace}`

**Importance:** High

**Type:** String

**Default Value:** ${namespace}.${tableName}Key



^^^^^^^^^^^^^^^^^^^^^^^
schema.namespace.format
^^^^^^^^^^^^^^^^^^^^^^^

The namespace for the schemas generated by the connector. The format in this setting will be used to create the ${namespace}variable which is available for use in the other configuration templates. The following template variables are available for string replacement. `${databaseName}`, `${schemaName}`, `${tableName}`, `${namespace}`

**Importance:** High

**Type:** String

**Default Value:** com.example.data.${databaseName}



^^^^^^^^^^^^^^^^^^^^^^^^
schema.value.name.format
^^^^^^^^^^^^^^^^^^^^^^^^

Format used to generate the name for the value schema. The following template variables are available for string replacement. `${databaseName}`, `${schemaName}`, `${tableName}`, `${namespace}`

**Importance:** High

**Type:** String

**Default Value:** ${namespace}.${tableName}Value



^^^^^^^^^^^^^^^
schema.cache.ms
^^^^^^^^^^^^^^^

The number of milliseconds to cache key and value schema metadata in memory.

**Importance:** Low

**Type:** Int

**Default Value:** 300000

**Validator:** [60000,...]



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
schema.caseformat.column.name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This setting is used to control how the column names are cased when the resulting schemas are generated.

**Importance:** Low

**Type:** String

**Default Value:** UPPER_UNDERSCORE

**Validator:** ValidEnum{enum=CaseFormat, allowed=[LOWER_HYPHEN, LOWER_UNDERSCORE, LOWER_CAMEL, LOWER, UPPER_CAMEL, UPPER_UNDERSCORE, UPPER, NONE]}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
schema.caseformat.database.name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This setting is used to control how the `${databaseName}` variable is cased when it is passed to the formatters defined in the `schema.namespace.format`, `schema.key.name.format`, `schema.value.name.format`, `topicFormat.format` settings. This allows you to control the naming applied to these properties. For example this can be used to take a database name of `USER_TRACKING` to a more java like case of `userTracking` or all lowercase `usertracking`.

**Importance:** Low

**Type:** String

**Default Value:** UPPER_UNDERSCORE

**Validator:** ValidEnum{enum=CaseFormat, allowed=[LOWER_HYPHEN, LOWER_UNDERSCORE, LOWER_CAMEL, LOWER, UPPER_CAMEL, UPPER_UNDERSCORE, UPPER, NONE]}



^^^^^^^^^^^^^^^^^^^^^^^
schema.caseformat.input
^^^^^^^^^^^^^^^^^^^^^^^

The naming convention used by the database format. This is used to define the source naming convention used by the other `schema.caseformat.*` properties.

**Importance:** Low

**Type:** String

**Default Value:** UPPER_UNDERSCORE

**Validator:** ValidEnum{enum=CaseFormat, allowed=[LOWER_HYPHEN, LOWER_UNDERSCORE, LOWER_CAMEL, UPPER_CAMEL, UPPER_UNDERSCORE]}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
schema.caseformat.schema.name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This setting is used to control how the `${schemaName}` variable is cased when it is passed to the formatters defined in the `schema.namespace.format`, `schema.key.name.format`, `schema.value.name.format`, `topicFormat.format` settings. This allows you to control the naming applied to these properties. For example this can be used to take a schema name of `SCOTT` to a more java like case of `Scott` or all lowercase `scott`.

**Importance:** Low

**Type:** String

**Default Value:** UPPER_UNDERSCORE

**Validator:** ValidEnum{enum=CaseFormat, allowed=[LOWER_HYPHEN, LOWER_UNDERSCORE, LOWER_CAMEL, LOWER, UPPER_CAMEL, UPPER_UNDERSCORE, UPPER, NONE]}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^
schema.caseformat.table.name
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This setting is used to control how the `${tableName}` variable is cased when it is passed to the formatters defined in the `schema.namespace.format`, `schema.key.name.format`, `schema.value.name.format`, `topicFormat.format` settings. This allows you to control the naming applied to these properties. For example this can be used to take a table name of `USER_SETTING` to a more java like case of `UserSetting` or all lowercase `usersetting`.

**Importance:** Low

**Type:** String

**Default Value:** UPPER_UNDERSCORE

**Validator:** ValidEnum{enum=CaseFormat, allowed=[LOWER_HYPHEN, LOWER_UNDERSCORE, LOWER_CAMEL, LOWER, UPPER_CAMEL, UPPER_UNDERSCORE, UPPER, NONE]}



---------------
Source Database
---------------


^^^^^^^^^^^^^^^
backoff.time.ms
^^^^^^^^^^^^^^^

The number of milliseconds to backoff when no records are returned from the source database.

**Importance:** Low

**Type:** Int

**Default Value:** 1000

**Validator:** [50,...]



------
Target
------


^^^^^^^^^^^^^^^^^^
topicFormat.format
^^^^^^^^^^^^^^^^^^

The format that will be used to build the topic name. This allows database tables to be broken up across several topics. The following template variables can be used for string replacements. `${databaseName}`, `${schemaName}`, `${tableName}`, `${namespace}`

**Importance:** High

**Type:** String

**Default Value:** ${databaseName}.${tableName}



^^^^^^^^^^
batch.size
^^^^^^^^^^

The target number of records to return during each poll from the Connect framework. This setting is independent from the general producer setting `batch.size`

**Importance:** Low

**Type:** Int

**Default Value:** 512

**Validator:** [1,...]



^^^^^^^^^^^^^^^^^^^^^
uncomitted.record.max
^^^^^^^^^^^^^^^^^^^^^

The maximum number of records to allow in memory. Once this limit is reached the record deque will block to prevent running out of memory.

**Importance:** Low

**Type:** Int

**Default Value:** 50000

**Validator:** [100,...]



^^^^^^^^^^^^^^^^^^^^^^^^^^^^
uncomitted.record.timeout.ms
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The maximum amount of time to wait when writing to the deque before throwing a timeout exception.

**Importance:** Low

**Type:** Long

**Default Value:** 300000

**Validator:** [100,...]






--------
Examples
--------

^^^^^^^
Minimal
^^^^^^^

This example will connect to a database server and use any table configured with change tracking.


.. NOTE::
    Increasing `tasks.max` will help increase the speed at which changes are imported. This comes with the side affect of increased connections/load on the source SQL Server.



Select one of the following configuration methods based on how you have deployed Kafka Connect.
Distributed Mode will the the JSON / REST examples. Standalone mode will use the properties based
example.


**Distributed Mode Json**

.. literalinclude:: MsSqlSourceConnector.minimal.example.json
    :language: JSON


**Standalone Mode Properties**

.. literalinclude:: MsSqlSourceConnector.minimal.example.properties
    :language: properties



^^^^^^^^^^^^^^^
Specific Tables
^^^^^^^^^^^^^^^

This example will connect to a SQL Server and will only check for changes from specific tables.



Select one of the following configuration methods based on how you have deployed Kafka Connect.
Distributed Mode will the the JSON / REST examples. Standalone mode will use the properties based
example.


**Distributed Mode Json**

.. literalinclude:: MsSqlSourceConnector.specific_tables.example.json
    :language: JSON


**Standalone Mode Properties**

.. literalinclude:: MsSqlSourceConnector.specific_tables.example.properties
    :language: properties




